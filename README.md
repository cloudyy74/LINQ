### Примеры
__Пример 1__:

```c++
int xs[] = { 1, 2, 3, 4, 5 };
std::vector<int> res =
  from(xs, xs + 5)  // Взять элементы xs
  .select([](int x) { return x * x; })  // Возвести в квадрат
  .where_neq(25)    // Оставить только значения != 25
  .where([](int x) { return x > 3; })   // Оставить только значения > 3
  .drop(2)          // Убрать два элемента из начала
  .to_vector();     // Преобразовать результат в вектор
```

__Пример 2__:

```c++
std::istream_iterator<int> in(std::cin), eof;
std::cout <<
  from(in, eof)  // Взять числа из входного потока
  .take(4)       // Не более четырёх чисел
  .until_eq(-1)  // Перестать читать после прочтения -1
  .to_vector();  // Получить список считанных чисел
```

__Пример 3__:
```c++
int xs[] = { 1, 2, 3, 4, 5 };
std::vector<double> res =
  from(xs, xs + 5)  // Взять элементы xs
  .select<double>([](int x) { return sqrt(x); })  // Извлечь корень
  .to_vector();     // Преобразовать результат в вектор
```

__Пример 4__:
```c++
std::istream_iterator<int> in(std::cin), eof;
std::ostream_iterator<double> out(std::cout, "\n");
from(in, eof)    // Взять числа из входного потока
.select([](int x) { return sqrt(x); })  // Извлечь из каждого корень
.copy_to(out);  // Вывести на экран
```
### Поддерживаемые методы
1. Генерация последовательностей:
  * `from(T begin, T end)` — генерирует
    последовательность из STL-полуинтервала `[begin; end)`.
  Исходный контейнер не должен изменяться никаким образом.
2. Преобразования последовательностей:
  * `.drop(count)` — удаляет из последовательности первые `count` элементов.
    Если последовательность была короче, она становится пустой.
  * `.take(count)` — оставляет в последовательности только первые `count`
    элементов. Если последовательность была короче, остаётся вся последовательность.
  * `.select(f)` — применяет функцию `f` к каждом элементу последовательности.
    `f` может изменять тип элемента — в таком случае требуется
    явное указание нового типа синтаксисом `.select<T>(f)` (как в примере 3).
  * `.until(f)` — обрывает последовательность, как только встретит элемент,
    удовлетворяющий предикату `f`, или если последовательность закончилась.
  * `.until_eq(v)` обрывает последовательность, как только встретит элемент,
    равный `v`, или если последовательность закончилась.
  * `.where(f)` — оставляет в последовательности только те элементы, которые
    удовлетворяют предикату `f`. `f` — это произвольный функциональный
    объект (функция, функтор, лямбда).
  * `.where_neq(v)` — оставляет в последовательность только элементы, не равные
    `v`.
3. Терминальные команды:
  * `.to_vector()` — собирает все элементы в вектор и возвращает его.
  * `.copy_to(iter)` — копирует сгенерированную последовательность в
    STL-подобный итератор `iter` (аналогично алгоритму `std::copy`).
    Например, это может быть `ostream_iterator` (пример 4),
    `back_inserter` или обычный итератор (если мы заранее знаем количество
    элементов).

### Поддерживаемые типы
* Все элементы, возникающие в процессе вычислений, имеют тип с:
  * Конструктором по умолчанию.
  * Конструктором копирования и оператором присваивания.
  * Опционально: конструктором перемещения и оператором перемещающего присваивания.
    По возможности следует использоавть их.
* Все функторы поддерживают:
  * Вызов константного `operator()`.
  * Перемещение.
